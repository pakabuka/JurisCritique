<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>JurisCritique</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- Google Fonts for a modern look -->
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
  <!-- Load PDF.js from CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.min.js"></script>
  <!-- Load Tesseract.js for OCR -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.0.2/dist/tesseract.min.js"></script>
  <!-- Load GPT tokenizer library -->
  <script src="https://unpkg.com/gpt-tokenizer"></script>
  <!-- Load jsPDF (not used because only Word download is enabled) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <style>
    /* Global Reset & Fonts */
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: 'Roboto', sans-serif;
      background: linear-gradient(135deg, #0b0c10, #1f2833);
      color: #333;
      overflow-x: hidden;
      position: relative;
      padding-bottom: 50px;
    }
    /* Starry background overlay */
    body::before {
      content: "";
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='100' height='100'><circle cx='50' cy='50' r='1' fill='white'/></svg>") repeat;
      opacity: 0.3;
      animation: starryNight 100s linear infinite;
      z-index: -2;
    }
    @keyframes starryNight {
      from { background-position: 0 0; }
      to { background-position: -1000px -1000px; }
    }
    /* Spinner Styles */
    .spinner {
      border: 4px solid rgba(0,0,0,0.1);
      border-left-color: #001f3f;
      border-radius: 50%;
      width: 24px;
      height: 24px;
      animation: spin 1s linear infinite;
      display: inline-block;
      vertical-align: middle;
      margin-left: 10px;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    /* Modal Styles */
    .modal {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.6);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 2000;
    }
    .modal-content {
      background: rgba(255, 255, 255, 0.9);
      padding: 20px 30px;
      border-radius: 8px;
      text-align: center;
      max-width: 400px;
      width: 90%;
      animation: modalIn 0.5s ease-out;
      border: 2px solid #fff;
    }
    @keyframes modalIn {
      from { opacity: 0; transform: scale(0.8); }
      to { opacity: 1; transform: scale(1); }
    }
    @keyframes modalOut {
      from { opacity: 1; transform: scale(1); }
      to { opacity: 0; transform: scale(0.8); }
    }
    .closing { animation: modalOut 0.3s ease-in forwards; }
    .modal-content input {
      width: 100%; padding: 10px; margin: 10px 0; font-size: 16px;
    }
    .disclaimer { font-size: 14px; color: #666; margin-bottom: 10px; }
    /* Header Styles */
    header {
      position: relative;
      text-align: center;
      padding: 20px 10px;
      background: inherit;
      color: #fff;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
      overflow: hidden;
      height: 80px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      margin-bottom: 20px;
    }
    header h1 {
      font-size: 32px; margin: 0;
      animation: zoomInOut 5s infinite;
      position: relative; z-index: 1;
    }
    @keyframes zoomInOut {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }
    #header-subtitle {
      font-size: 16px;
      margin-top: 5px;
      font-style: italic;
      color: #e0e0e0;
      position: relative;
      z-index: 1;
      height: 20px;
    }
    /* Front Page Wrapper */
    #front-page-wrapper {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
    }
    #main-page {
      max-width: 600px;
      margin: 0 auto;
    }
    /* Drag & Drop Area modifications */
    #drop-area {
      border: 2px dashed rgba(255,255,255,0.5);
      border-radius: 10px;
      padding: 40px;
      text-align: center;
      background: transparent !important;
      transition: background 0.3s, border-color 0.3s;
      cursor: pointer;
      margin-bottom: 20px;
    }
    #drop-area p { font-size: 18px; margin-bottom: 20px; color: #fff; }
    #drop-area:hover { background: transparent !important; }
    /* White border for buttons */
    #drop-area .btn, #summary-page .btn {
      border: 2px solid #fff;
    }
    /* File List and other elements remain unchanged */
    #file-list { margin-top: 20px; }
    .file-item {
      background: #fff;
      border: 1px solid #e0e0e0;
      border-radius: 8px;
      padding: 15px 20px;
      margin-bottom: 15px;
      display: flex;
      align-items: center;
      gap: 15px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.05);
      transition: transform 0.2s;
      position: relative;
    }
    .file-item:hover { transform: translateY(-2px); }
    .file-item .icon { font-size: 50px; }
    .file-details { flex: 1; }
    .file-details p { margin: 3px 0; font-size: 15px; }
    .progress-container {
      background: #e0e0e0;
      border-radius: 5px;
      overflow: hidden;
      margin: 10px 0;
      height: 20px;
    }
    .progress-bar {
      width: 0%;
      height: 100%;
      background: linear-gradient(90deg, #001f3f, #555);
      text-align: center;
      color: #fff;
      line-height: 20px;
      transition: width 0.2s ease;
    }
    .remove-file {
      position: absolute;
      top: 5px;
      right: 5px;
      cursor: pointer;
      font-size: 20px;
      color: #ff5722;
    }
    @keyframes removeAnimation {
      0% { opacity: 1; transform: scale(1); }
      100% { opacity: 0; transform: scale(0.5) rotate(45deg); }
    }
    .removing { animation: removeAnimation 0.5s forwards; }
    /* Button styles */
    .button-container { 
      margin-top: 10px; 
      position: relative; 
      padding-right: 40px; /* extra space to avoid overlap with the indicator */
    }
    .btn {
      background-color: #001f3f;
      color: #fff;
      border: none;
      padding: 10px 20px;
      font-size: 16px;
      border-radius: 5px;
      transition: background-color 0.3s ease, transform 0.2s ease;
      cursor: pointer;
      margin-right: 5px;
    }
    .btn:hover { background-color: #003366; transform: scale(1.05); }
    .btn:disabled { background-color: #aaa; cursor: not-allowed; }
    /* Summary Page */
    #summary-page {
      display: none;
      background: transparent;
      padding: 20px 20px 0 20px;
      color: #fff;
      min-height: 100vh;
      box-sizing: border-box;
      flex-direction: row;
      gap: 20px;
      position: relative;
    }
    #summary-page.flex {
      display: flex;
    }
    /* Back Button */
    #back-button {
      position: absolute;
      top: 20px;
      left: 20px;
      padding: 8px 12px;
      font-size: 14px;
      z-index: 1001;
    }
    /* Summary columns */
    .summary-left {
      flex: 1;
      height: calc(100vh - 80px);
      overflow-y: auto;
      padding: 70px 10px 10px 10px;
    }
    .summary-right {
      flex: 1;
      height: calc(100vh - 80px);
      position: relative;
    }
    /* PDF viewer wrapper */
    #pdf-viewer-wrapper {
      max-height: 100%;
      overflow-y: auto;
      position: relative;
      padding-top: 0;
    }
    /* White separation line between summary sections */
    .summary-left .section:not(:last-child) {
      border-bottom: 1px solid #fff;
      padding-bottom: 20px;
      margin-bottom: 20px;
    }
    /* Page link styling */
    .page-link {
      color: #fff;
      text-decoration: underline;
      cursor: pointer;
    }
    .page-link:hover { color: #f0f0f0; }
    /* Fade-in Animation */
    @keyframes fadeInPage {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }
    .fade-in {
      animation: fadeInPage 0.6s ease-out;
    }
    /* Fade-out Animation */
    @keyframes fadeOutPage {
      from { opacity: 1; }
      to { opacity: 0; }
    }
    .fade-out {
      animation: fadeOutPage 0.3s ease-out forwards;
    }
    /* Chatbot Styles */
    .chatbot-container {
      width: 350px;
      max-height: 500px;
      background: #fff;
      border: 1px solid #e0e0e0;
      border-radius: 10px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.2);
      display: flex;
      flex-direction: column;
      z-index: 1000;
      resize: both;
      overflow: auto;
      opacity: 0;
      transform: translateY(20px);
      pointer-events: none;
      transition: opacity 0.3s ease, transform 0.3s ease;
      position: fixed;
      bottom: 70px;
      right: 20px;
    }
    .chatbot-container.visible {
      opacity: 1;
      transform: translateY(0);
      pointer-events: auto;
    }
    .chatbot-drag-handle {
      position: absolute;
      top: 2px;
      left: 2px;
      width: 20px;
      height: 20px;
      background: #001f3f;
      border-radius: 3px;
      cursor: nwse-resize;
      z-index: 1010;
    }
    .chatbot-header {
      background: #001f3f;
      color: #fff;
      padding: 10px 10px 10px 30px;
      border-top-left-radius: 10px;
      border-top-right-radius: 10px;
      text-align: center;
      font-weight: bold;
      font-size: 18px;
    }
    .chatbot-messages {
      flex: 1;
      padding: 10px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 5px;
      background: #f7f7f7;
    }
    .chatbot-input-container {
      display: flex;
      border-top: 1px solid #e0e0e0;
    }
    .chatbot-input-container input {
      flex: 1;
      border: none;
      padding: 10px;
      font-size: 16px;
    }
    .chatbot-input-container button {
      border: none;
      background: #001f3f;
      color: #fff;
      padding: 10px;
      cursor: pointer;
      font-size: 16px;
    }
    .chatbot-toggle {
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 50px;
      height: 50px;
      background: rgba(128,128,128,0.7);
      color: #fff;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 24px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.3);
      z-index: 3000;
      transition: transform 0.2s ease;
    }
    .chatbot-toggle:active { transform: scale(0.9); }
    .chatbot-message {
      margin-bottom: 5px;
      padding: 8px;
      border-radius: 5px;
      max-width: 80%;
      font-size: 16px;
    }
    .chatbot-message.user {
      background: #001f3f;
      color: #fff;
      align-self: flex-end;
    }
    .chatbot-message.bot {
      background: #eee;
      color: #333;
      align-self: flex-start;
    }
    .chatbot-message.typing { font-style: italic; color: #999; }
    /* Info Button Styles */
    #info-button {
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 50px;
      height: 50px;
      background: rgba(128,128,128,0.5);
      color: #fff;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      cursor: pointer;
      z-index: 3000;
    }
    #drop-area.highlight {
      background: rgba(255, 255, 255, 0.1);
      border-color: #fff;
      transform: scale(1.02);
      transition: transform 0.2s ease, background 0.2s ease, border-color 0.2s ease;
    }
    /* Recommended Action Indicator (the dot) */
    .action-indicator {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      border: 2px solid #fff;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    /* Custom Tooltip Styles */
    .tooltip {
      position: absolute;
      background: rgba(0, 0, 0, 0.85);
      color: #fff;
      padding: 10px 15px;
      border-radius: 8px;
      font-size: 14px;
      z-index: 10000;
      text-align: center;
      max-width: 90vw;
      white-space: normal;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }
  </style>
</head>
<body>
  <!-- Token Modal -->
  <div id="token-modal" class="modal">
    <div class="modal-content">
      <h2>Enter your OpenAI API Key</h2>
      <p class="disclaimer">We DO NOT collect or store your key.</p>
      <input type="text" id="open-token-input" placeholder="Paste your OpenAI API Key here...">
      <p class="disclaimer">
        <a href="https://help.openai.com/en/articles/4936850-where-do-i-find-my-openai-api-key" target="_blank">
          Where do I find my OpenAI API Key?
        </a>
      </p>
      <button id="open-token-submit" class="btn">Submit</button>
      <p id="token-error" style="color:red; display:none;"></p>
    </div>
  </div>

  <!-- Info Modal -->
  <div id="info-modal" class="modal">
    <div class="modal-content">
      <h2>About JurisCritique</h2>
      <p>JurisCritique is a powerful tool that extracts text from PDF documents using OCR and then uses AI to provide a detailed review of law article submissions. Acting as if you were a Yale Law Journal reviewer, the AI evaluates articles on multiple criteria—including originality, legal analysis, methodology, and policy implications—to help determine their scholarly merit. Your privacy is respected and no data is stored.</p>
      <p>© 2025 Frederick Liu. All rights reserved.</p>
      <button id="info-close" class="btn">Close</button>
    </div>
  </div>

  <!-- Info Button -->
  <div id="info-button">i</div>

  <!-- Front Page Wrapper -->
  <div id="front-page-wrapper">
    <header>
      <h1>JurisCritique</h1>
      <p id="header-subtitle">Critique legal scholarship with insight</p>
    </header>

    <!-- Summary Page – used as the whole page container when active -->
    <div class="container" id="summary-page"></div>

    <!-- Main Page -->
    <div class="container" id="main-page">
      <div id="drop-area">
        <p>Drag &amp; drop your PDF files here</p>
        <button id="fileSelect" class="btn">Select Files</button>
        <input type="file" id="fileElem" multiple accept="application/pdf" style="display:none;">
      </div>
      <div id="file-list"></div>
    </div>
  </div>

  <script>
    // Global variable for the token.
    let OPENAI_API_KEY = "";
    
    /********************************************************************
     * Token Validation and Modal Handling
     ********************************************************************/
    async function validateToken(token) {
      try {
        const response = await fetch("https://api.openai.com/v1/models", {
          headers: { "Authorization": "Bearer " + token }
        });
        return response.ok;
      } catch (error) { return false; }
    }
    
    window.addEventListener("load", () => {
      const savedToken = sessionStorage.getItem("openToken");
      if (savedToken) { OPENAI_API_KEY = savedToken; }
      else { document.getElementById("token-modal").style.display = "flex"; }
      startTypingAnimation(); // start header subtitle animation
    });
    
    document.getElementById("open-token-submit").addEventListener("click", async function(){
      const tokenInput = document.getElementById("open-token-input");
      const token = tokenInput.value.trim();
      const errorMsg = document.getElementById("token-error");
      if (token === "") {
        errorMsg.textContent = "API Key cannot be empty.";
        errorMsg.style.display = "block";
        return;
      }
      const isValid = await validateToken(token);
      if (isValid) {
        const modalContent = document.querySelector("#token-modal .modal-content");
        modalContent.classList.add("closing");
        modalContent.addEventListener("animationend", function handler() {
          document.getElementById("token-modal").style.display = "none";
          modalContent.classList.remove("closing");
          modalContent.removeEventListener("animationend", handler);
        });
        OPENAI_API_KEY = token;
        sessionStorage.setItem("openToken", token);
      } else {
        errorMsg.textContent = "Invalid API Key. Please try again.";
        errorMsg.style.display = "block";
      }
    });

    // Info Modal handling with animated close
    document.getElementById("info-button").addEventListener("click", () => {
      document.getElementById("info-modal").style.display = "flex";
    });
    document.getElementById("info-close").addEventListener("click", () => {
      const infoModalContent = document.querySelector("#info-modal .modal-content");
      infoModalContent.classList.add("closing");
      infoModalContent.addEventListener("animationend", function handler() {
        document.getElementById("info-modal").style.display = "none";
        infoModalContent.classList.remove("closing");
        infoModalContent.removeEventListener("animationend", handler);
      });
    });
    
    /********************************************************************
     * Typing Animation for Header Subtitle
     ********************************************************************/
    function startTypingAnimation() {
      const element = document.getElementById("header-subtitle");
      const fullText = element.textContent;
      let charIndex = 0;
      let typing = true;
      function type() {
        if (typing) {
          charIndex++;
          if (charIndex > fullText.length) { typing = false; setTimeout(type, 1000); }
          else { element.textContent = fullText.substring(0, charIndex); setTimeout(type, 100); }
        } else {
          charIndex--;
          if (charIndex < 0) { typing = true; setTimeout(type, 500); }
          else { element.textContent = fullText.substring(0, charIndex); setTimeout(type, 50); }
        }
      }
      type();
    }
    
    /********************************************************************
     * Tokenizer Setup
     ********************************************************************/
    let encode;
    if (typeof GPTTokenizer_cl100k_base !== "undefined" && GPTTokenizer_cl100k_base.encode) {
      encode = GPTTokenizer_cl100k_base.encode;
    } else { encode = function(text) { return text.split(/\s+/); }; }
    
    /********************************************************************
     * Text Preprocessing Helper
     ********************************************************************/
    function preprocessText(text) {
      return text.replace(/\s+/g, ' ').trim();
    }
    
    /********************************************************************
     * Global DOM Elements and Variables
     ********************************************************************/
    const dropArea = document.getElementById('drop-area');
    const fileElem = document.getElementById('fileElem');
    const fileSelect = document.getElementById('fileSelect');
    const fileList = document.getElementById('file-list');
    const mainPage = document.getElementById('main-page');
    const summaryPage = document.getElementById('summary-page');
    const filesData = {};
    let pdfScale = 1.2;
    let currentDocumentOriginalText = "";
    let chatMemory = [];
    
    /********************************************************************
     * File Selection and Drag & Drop Event Listeners
     ********************************************************************/
    fileSelect.addEventListener('click', () => fileElem.click());
    fileElem.addEventListener('change', handleFiles);
    dropArea.addEventListener('dragover', function(e) {
      e.preventDefault();
      dropArea.classList.add('highlight');
    });
    dropArea.addEventListener('dragleave', function(e) {
      e.preventDefault();
      dropArea.classList.remove('highlight');
    });
    dropArea.addEventListener('drop', function(e) {
      e.preventDefault();
      dropArea.classList.remove('highlight');
      const files = e.dataTransfer.files;
      if (files && files.length > 0) {
        handleFiles({ target: { files: files } });
      }
    });
    
    /********************************************************************
     * Dynamic Progress Bar Animation
     ********************************************************************/
    function updateProgress(fileId, target) {
      const progressBar = document.getElementById('progress-' + fileId);
      if (!progressBar) return;
      let current = parseInt(progressBar.textContent) || 0;
      const interval = setInterval(() => {
        if (current < target) {
          current++;
          progressBar.style.width = current + "%";
          progressBar.textContent = current + "%";
        } else { clearInterval(interval); }
      }, 20);
    }
    
    /********************************************************************
     * File Processing: Create file item with button container
     ********************************************************************/
    function handleFiles(e) {
      const files = e.target.files;
      for (let file of files) {
        if (file.type !== "application/pdf") continue;
        processFile(file);
      }
    }
    
    function processFile(file) {
      const fileId = 'file-' + Math.random().toString(36).substr(2, 9);
      const fileItem = document.createElement('div');
      fileItem.className = 'file-item';
      fileItem.id = fileId;
      fileItem.innerHTML = `
        <span class="remove-file" title="Remove File">x</span>
        <div class="icon">📄</div>
        <div class="file-details">
          <p><strong>${file.name}</strong></p>
          <p>
            ${(file.size / 1024).toFixed(2)} KB
            <span class="token-info" id="token-info-${fileId}" style="font-size: 12px; color: #555; margin-left: 10px;">
              Tokens: 0 | Cost: $0.00
            </span>
          </p>
          <div class="progress-container">
            <div class="progress-bar" id="progress-${fileId}">0%</div>
          </div>
          <div class="button-container">
            <button id="submit-btn-${fileId}" class="btn">Evaluate</button>
            <button id="proceed-btn-${fileId}" class="btn" style="display:none;">Proceed</button>
            <button id="summary-btn-${fileId}" class="btn" style="display:none;">View Review</button>
          </div>
        </div>
      `;
      fileList.appendChild(fileItem);
      
      const removeIcon = fileItem.querySelector('.remove-file');
      removeIcon.addEventListener('click', (e) => {
        e.stopPropagation();
        fileItem.classList.add("removing");
        fileItem.addEventListener("animationend", () => {
          if(fileList.contains(fileItem)) { fileList.removeChild(fileItem); }
          delete filesData[fileId];
        });
      });
      
      const submitBtn = document.getElementById(`submit-btn-${fileId}`);
      submitBtn.addEventListener('click', () => {
        submitBtn.style.display = 'none';
        evaluateArticle(file, fileId);
      });
    }
    
    /********************************************************************
     * PDF Extraction & OCR Functions
     ********************************************************************/
    async function extractPDFText(file) {
      const pdfjsLib = window["pdfjs-dist/build/pdf"];
      pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.worker.min.js";
      const arrayBuffer = await file.arrayBuffer();
      const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
      let fullText = "";
      for (let i = 1; i <= pdf.numPages; i++) {
        const page = await pdf.getPage(i);
        const viewport = page.getViewport({ scale: 1.5 });
        const canvas = document.createElement("canvas");
        const context = canvas.getContext("2d");
        canvas.width = viewport.width;
        canvas.height = viewport.height;
        await page.render({ canvasContext: context, viewport: viewport }).promise;
        const hasTwoColumns = await detectTwoColumns(canvas, context);
        let pageText = "";
        if (hasTwoColumns) {
          const leftCanvas = document.createElement("canvas");
          leftCanvas.width = Math.floor(canvas.width / 2);
          leftCanvas.height = canvas.height;
          const leftCtx = leftCanvas.getContext("2d");
          leftCtx.drawImage(canvas, 0, 0, leftCanvas.width, leftCanvas.height);
          const rightCanvas = document.createElement("canvas");
          rightCanvas.width = Math.ceil(canvas.width / 2);
          rightCanvas.height = canvas.height;
          const rightCtx = rightCanvas.getContext("2d");
          rightCtx.drawImage(canvas, leftCanvas.width, 0, rightCanvas.width, rightCanvas.height);
          const leftText = await performOCR(leftCanvas);
          const rightText = await performOCR(rightCanvas);
          pageText = leftText + "\n" + rightText;
        } else {
          pageText = await performOCR(canvas);
        }
        fullText += pageText + "\n";
      }
      return fullText;
    }
    
    async function detectTwoColumns(canvas, context) {
      const imgData = context.getImageData(0, 0, canvas.width, canvas.height);
      const data = imgData.data;
      const textPixelThreshold = 200;
      const nonWhitePixelCount = (xStart, xEnd) => {
        let count = 0;
        for (let y = 0; y < canvas.height; y++) {
          for (let x = xStart; x < xEnd; x++) {
            const index = (y * canvas.width + x) * 4;
            const brightness = (data[index] + data[index+1] + data[index+2]) / 3;
            if (brightness < textPixelThreshold) count++;
          }
        }
        return count;
      };
      const midX = Math.floor(canvas.width / 2);
      const leftCount = nonWhitePixelCount(0, midX);
      const rightCount = nonWhitePixelCount(midX, canvas.width);
      const ratio = leftCount / rightCount;
      const minCount = 10000, maxRatio = 1.5;
      return (leftCount > minCount && rightCount > minCount && ratio > (1/maxRatio) && ratio < maxRatio);
    }
    
    async function performOCR(canvas) {
      try {
        const { data: { text } } = await Tesseract.recognize(canvas, 'eng', { logger: m => m });
        return text;
      } catch (error) {
        console.error("OCR Error:", error);
        return "";
      }
    }
    
    /********************************************************************
     * Evaluation & JSON Parsing (Article Review)
     ********************************************************************/
    async function evaluateArticle(file, fileId) {
      const progressBar = document.getElementById('progress-' + fileId);
      const summaryBtn = document.getElementById('summary-btn-' + fileId);
      const fileItem = document.getElementById(fileId);
      const buttonContainer = fileItem.querySelector('.button-container');
      
      let initialSpinner = document.createElement("div");
      initialSpinner.className = "spinner";
      buttonContainer.appendChild(initialSpinner);
      
      try {
        updateProgress(fileId, 20);
        const pdfText = await extractPDFText(file);
        updateProgress(fileId, 40);
        
        const cleanedText = preprocessText(pdfText);
        const tokenCount = encode(cleanedText).length;
        if (tokenCount > 200000) {
          const errorMsg = document.createElement("p");
          errorMsg.style.color = "red";
          errorMsg.textContent = "Unable to process file due to large token count.";
          fileItem.appendChild(errorMsg);
          initialSpinner.remove();
          return;
        }
        
        const tokenCost = ((tokenCount / 1000000) * 1.10).toFixed(2);
        document.getElementById(`token-info-${fileId}`).innerText = `Tokens: ${tokenCount} | Cost: $${tokenCost}`;
        
        filesData[fileId] = { file: file, originalText: cleanedText };
        
        initialSpinner.remove();
    
        let proceedBtn = document.getElementById(`proceed-btn-${fileId}`);
        summaryBtn.style.display = "none";
        proceedBtn.style.display = "inline-block";
    
        proceedBtn.addEventListener("click", async function onProceed() {
          proceedBtn.style.display = "none";
          proceedBtn.removeEventListener("click", onProceed);
          let proceedSpinner = document.createElement("div");
          proceedSpinner.className = "spinner";
          buttonContainer.appendChild(proceedSpinner);
    
          // Updated prompt with instructions to ignore OCR typos, include scoring and JSON format
          const prompt = `Imagine that you are a law articles reviewer for the Yale Law Journal. When reviewing, please ignore any minor typos that might have been introduced by OCR errors.

Review the following article submission for a law school’s law review/journal. Provide extremely detailed feedback—quote the original article where appropriate.

1. Policy and Practical Implications:
   - Application: Does the article move beyond abstract theory to address how its findings or proposals might affect real-world legal practice or policy reform?
   - Recommendations: Are any suggested reforms or critiques grounded in solid evidence and feasible within the current legal framework?

2. Originality and Contribution to the Field:
   - Novelty: Does the article offer a fresh perspective or innovative argument on a legal issue?
   - Scholarly Contribution: Does it advance current debates or fill a gap in the literature? Consider whether it challenges established doctrines or proposes a new framework that could influence future legal scholarship or practice.

3. Quality of Legal Analysis and Argumentation:
   - Depth and Rigor: Is the legal reasoning robust, well-researched, and thoroughly developed?
   - Coherence: Are the arguments logically structured and do they follow a clear, persuasive line of reasoning from premises to conclusions?
   - Support: Does the article effectively employ primary sources (cases, statutes, regulations) and secondary sources (treatises, law review articles) to support its claims?

4. Methodology and Theoretical Framework:
   - Appropriateness: Is the chosen methodology (doctrinal, comparative, empirical, interdisciplinary, etc.) suitable for the question at hand?
   - Execution: Are the methods applied with precision and rigor? For empirical or interdisciplinary work, are data and analytical techniques valid and transparent?

Additionally, include an extra section labeled "Abstract" that provides a detailed summary of the article—explaining what it is about, its main point, major arguments, and quoting key passages where relevant.

For each of the four criteria, assign a score using the following weights:
- **Quality of Legal Analysis and Argumentation:** up to **4 points**
- **Originality and Contribution to the Field:** up to **2 points**
- **Policy and Practical Implications:** up to **1 point**
- **Methodology and Theoretical Framework:** up to **3 points**

Compute a **total score** (out of 10). In order for an article to be accepted, it must score at least **6 points** overall.

Based on your evaluation, please also provide a recommended action: "accept" or "reject".

Output the review as valid JSON strictly following this format (and nothing else):

{
  "title": "Review of ${file.name}",
  "evaluations": {
      "Policy and Practical Implications": "Your detailed evaluation here.",
      "Originality and Contribution to the Field": "Your detailed evaluation here.",
      "Quality of Legal Analysis and Argumentation": "Your detailed evaluation here.",
      "Methodology and Theoretical Framework": "Your detailed evaluation here."
  },
  "scores": {
      "Policy and Practical Implications": <score out of 1>,
      "Originality and Contribution to the Field": <score out of 2>,
      "Quality of Legal Analysis and Argumentation": <score out of 4>,
      "Methodology and Theoretical Framework": <score out of 3>,
      "total": <total score out of 10>
  },
  "abstract": "Your detailed abstract here.",
  "recommended_action": "accept" // or "reject"
}

Article Content:
${cleanedText}`;
    
          updateProgress(fileId, 60);
    
          const totalTokenLimit = 200000;
          const promptTokens = encode(prompt).length;
          const bufferTokens = 100;
          const computedCompletionTokens = totalTokenLimit - promptTokens - bufferTokens;
          const maxCompletionTokens = computedCompletionTokens > 1000 ? Math.min(computedCompletionTokens, 100000) : 1000;
    
          const response = await fetch("https://api.openai.com/v1/chat/completions", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "Authorization": `Bearer ${OPENAI_API_KEY}`
            },
            body: JSON.stringify({
              model: "o3-mini",
              messages: [{ role: "user", content: prompt }],
              max_completion_tokens: maxCompletionTokens
            })
          });
    
          updateProgress(fileId, 80);
          if (!response.ok) {
            proceedSpinner.remove();
            const errorMsg = document.createElement("p");
            errorMsg.style.color = "red";
            errorMsg.textContent = "OpenAI API error: " + response.statusText;
            fileItem.appendChild(errorMsg);
            return;
          }
          const data = await response.json();
          const evaluationOutput = data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.content
            ? data.choices[0].message.content.trim() : null;
          let structuredEvaluation;
          try {
            structuredEvaluation = JSON.parse(evaluationOutput);
          } catch (e) {
            structuredEvaluation = {
              title: `Review of ${file.name}`,
              evaluations: {
                "Policy and Practical Implications": "No evaluation generated.",
                "Originality and Contribution to the Field": "No evaluation generated.",
                "Quality of Legal Analysis and Argumentation": "No evaluation generated.",
                "Methodology and Theoretical Framework": "No evaluation generated."
              },
              scores: {
                "Policy and Practical Implications": 0,
                "Originality and Contribution to the Field": 0,
                "Quality of Legal Analysis and Argumentation": 0,
                "Methodology and Theoretical Framework": 0,
                "total": 0
              },
              abstract: "No abstract generated.",
              recommended_action: "reject"
            };
          }
          updateProgress(fileId, 100);
          filesData[fileId].evaluation = structuredEvaluation;
    
          proceedSpinner.remove();
          summaryBtn.style.display = "inline-block";
          summaryBtn.disabled = false;
          summaryBtn.addEventListener('click', () => showSummaryPage(fileId));
    
          // --- Download Button ---
          const downloadBtn = document.createElement("button");
          downloadBtn.id = `download-btn-${fileId}`;
          downloadBtn.className = "btn";
          downloadBtn.style.display = "inline-block";
          downloadBtn.innerHTML = "Download Review";
          downloadBtn.addEventListener('click', () => downloadFormattedSummary(filesData[fileId].evaluation, "word"));
          buttonContainer.appendChild(downloadBtn);
          // --- End Download Button ---
    
          // --- Create Action Indicator Container with Dot and Score ---
          const indicatorContainer = document.createElement("div");
          indicatorContainer.style.position = "absolute";
          indicatorContainer.style.bottom = "10px";
          indicatorContainer.style.right = "10px";
          indicatorContainer.style.display = "flex";
          indicatorContainer.style.alignItems = "center";
    
          const actionIndicator = document.createElement("div");
          actionIndicator.id = "action-indicator-" + fileId;
          actionIndicator.className = "action-indicator";
          // Leave the dot empty (no text)
          actionIndicator.textContent = "";
    
          // Read the total score from the evaluation
          const totalScore = structuredEvaluation.scores && structuredEvaluation.scores.total ? structuredEvaluation.scores.total : 0;
          let tooltipMessage = "";
    
          // Set the dot color based on recommended action
          if (structuredEvaluation.recommended_action.toLowerCase() === "accept") {
            actionIndicator.style.backgroundColor = "green";
            tooltipMessage = `Accepted (${totalScore}/10): The article demonstrates robust legal analysis, innovative insights, and practical policy implications.`;
          } else {
            actionIndicator.style.backgroundColor = "red";
            tooltipMessage = `Rejected (${totalScore}/10): The article did not meet the required scholarly standards in analysis, structure, or practical application.`;
          }
    
          // Create a separate span for the score (in black)
          const scoreSpan = document.createElement("span");
          scoreSpan.style.color = "#000";
          scoreSpan.style.marginLeft = "5px";
          scoreSpan.style.fontSize = "14px";
          scoreSpan.textContent = `${totalScore}/10`;
    
          // Attach tooltip to the container
          indicatorContainer.title = tooltipMessage;
    
          // On click, show a custom tooltip (same behavior as before)
          indicatorContainer.addEventListener("click", function(event) {
            event.stopPropagation();
            let tooltip = document.getElementById("tooltip-" + fileId);
            if (!tooltip) {
              tooltip = document.createElement("div");
              tooltip.id = "tooltip-" + fileId;
              tooltip.className = "tooltip";
              tooltip.textContent = tooltipMessage;
              document.body.appendChild(tooltip);
              const rect = indicatorContainer.getBoundingClientRect();
              const tooltipWidth = tooltip.offsetWidth;
              let leftPos = rect.left + rect.width / 2 - tooltipWidth / 2;
              leftPos = Math.max(10, Math.min(leftPos, window.innerWidth - tooltipWidth - 10));
              tooltip.style.left = leftPos + "px";
              let topPos = rect.top - tooltip.offsetHeight - 10;
              if (topPos < 10) { 
                topPos = rect.bottom + 10;
              }
              const downloadBtn = document.getElementById("download-btn-" + fileId);
              if (downloadBtn) {
                const downloadRect = downloadBtn.getBoundingClientRect();
                const tooltipRect = tooltip.getBoundingClientRect();
                if (tooltipRect.left < downloadRect.right &&
                    tooltipRect.right > downloadRect.left &&
                    tooltipRect.top < downloadRect.bottom &&
                    tooltipRect.bottom > downloadRect.top) {
                  topPos = downloadRect.top - tooltipRect.height - 10;
                }
              }
              tooltip.style.top = topPos + "px";
              setTimeout(() => { tooltip.remove(); }, 3000);
            }
          });
    
          indicatorContainer.appendChild(actionIndicator);
          indicatorContainer.appendChild(scoreSpan);
          fileItem.appendChild(indicatorContainer);
        });
      } catch (error) {
        console.error("Error processing PDF:", error);
        progressBar.style.background = "red";
        summaryBtn.textContent = "Error Evaluating";
      }
    }
    
    /********************************************************************
     * PDF Rendering & Gesture-Based Zoom Controls
     ********************************************************************/
    async function renderPDFPages(file, container, scale) {
      container.innerHTML = "";
      const pdfjsLib = window["pdfjs-dist/build/pdf"];
      pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.worker.min.js";
      const arrayBuffer = await file.arrayBuffer();
      const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
      for (let i = 1; i <= pdf.numPages; i++) {
        const page = await pdf.getPage(i);
        const viewport = page.getViewport({ scale: scale });
        const canvas = document.createElement("canvas");
        canvas.id = "pdf-page-" + i;
        canvas.style.marginBottom = "10px";
        canvas.style.transition = "transform 0.3s ease";
        canvas.width = viewport.width;
        canvas.height = viewport.height;
        const context = canvas.getContext("2d");
        await page.render({ canvasContext: context, viewport: viewport }).promise;
        container.appendChild(canvas);
      }
    }
    
    function navigateToPage(page) {
      const target = document.getElementById('pdf-page-' + page);
      if (target) target.scrollIntoView({ behavior: "smooth" });
      else alert("Page " + page + " not found.");
    }
    
    /********************************************************************
     * Content Formatting Helpers
     ********************************************************************/
    function formatContent(text) {
      if (!text) return "";
      const lines = text.split('\n');
      let html = '';
      let listOpen = false;
      lines.forEach(line => {
        line = line.trim();
        if (line.startsWith('- ') || line.startsWith('• ')) {
          if (!listOpen) { html += '<ul>'; listOpen = true; }
          let item = line.substring(2).trim();
          html += `<li>${item}</li>`;
        } else {
          if (listOpen) { html += '</ul>'; listOpen = false; }
          if (line) { html += `<p>${line}</p>`; }
        }
      });
      if (listOpen) { html += '</ul>'; }
      return html;
    }
    
    // Updated generateDetailedSummaryHTML function to add a new section between Recommended Action and Total Score
    function generateDetailedSummaryHTML(evaluation) {
      // Define maximum points for each criterion
      const maxPoints = {
        "Policy and Practical Implications": 1,
        "Originality and Contribution to the Field": 2,
        "Quality of Legal Analysis and Argumentation": 4,
        "Methodology and Theoretical Framework": 3
      };
      let html = `<h2>${evaluation.title}</h2>`;
      html += `<div class="section">
                <h3>Evaluation</h3>
                <div class="section-content">`;
      // List each evaluation (without individual score display)
      for (const criterion in evaluation.evaluations) {
        html += `<p><strong>${criterion}:</strong> ${evaluation.evaluations[criterion]}</p>`;
      }
      // Overall recommended action
      html += `<p><strong>Recommended Action:</strong> ${evaluation.recommended_action.toUpperCase()}</p>`;
      // New section for individual criterion scores
      html += `<div class="section">
                 <h4>Individual Criterion Scores:</h4>
                 <ul>`;
      for (const criterion in evaluation.scores) {
        if (criterion === "total") continue;
        html += `<li><strong>${criterion}:</strong> ${evaluation.scores[criterion]}/${maxPoints[criterion]}</li>`;
      }
      html += `</ul>
               </div>`;
      // Total Score
      html += `<p><strong>Total Score:</strong> ${evaluation.scores.total}/10</p>`;
      html += `</div>
              </div>`;
      if (evaluation.abstract) {
        html += `<div class="section">
                   <h3>Abstract</h3>
                   <div class="section-content">
                     <p>${evaluation.abstract}</p>
                   </div>
                 </div>`;
      }
      return html;
    }
    
    function generateWordDocumentHTML(evaluation) {
      let html = `
      <html>
      <head>
        <meta charset="UTF-8">
        <title>${evaluation.title}</title>
        <style>
          body { font-family: Arial, sans-serif; margin: 40px; }
          h1, h2, h3 { color: #001f3f; }
          h1 { font-size: 28px; text-align: center; margin-bottom: 20px; }
          h2 { font-size: 24px; margin-top: 20px; }
          h3 { font-size: 20px; margin-top: 15px; }
          p { font-size: 14px; line-height: 1.6; margin: 8px 0; }
          ul { margin: 10px 0 10px 20px; }
          .section { margin-bottom: 20px; }
          .analysis { background: #f0fff0; border: 1px solid #28a745; padding: 10px; }
        </style>
      </head>
      <body>
        <h1>${evaluation.title}</h1>
      `;
      html += `<div class="section">
                 <h2>Evaluation</h2>`;
      for (const criterion in evaluation.evaluations) {
        html += `<p><strong>${criterion}:</strong> ${evaluation.evaluations[criterion]}</p>`;
      }
      html += `<p><strong>Abstract:</strong> ${evaluation.abstract}</p>`;
      html += `<p><strong>Recommended Action:</strong> ${evaluation.recommended_action.toUpperCase()}</p>`;
      html += `<p><strong>Total Score:</strong> ${evaluation.scores.total}/10</p>`;
      html += `</div></body></html>`;
      return html;
    }
    
    function downloadFormattedSummary(evaluation, format) {
      let htmlContent = "";
      if (format === "word") { htmlContent = generateWordDocumentHTML(evaluation); }
      else { htmlContent = generateDetailedSummaryHTML(evaluation); }
      const blob = new Blob(['\ufeff', htmlContent], { type: 'application/msword' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = evaluation.title.replace(/\s+/g, '_') + ".doc";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }
    
    /********************************************************************
     * Display Review and PDF Viewer (Full-page Flex Layout with Smooth Transitions)
     ********************************************************************/
    async function showSummaryPage(fileId) {
      const data = filesData[fileId];
      if (!data) return;
      // Hide header and info button for a cleaner review page
      document.querySelector("header").style.display = "none";
      document.getElementById("info-button").style.display = "none";
      currentDocumentOriginalText = data.originalText;
      
      // Hide main page and build the review page using the entire page as container
      mainPage.style.display = 'none';
      summaryPage.classList.add("flex");
      summaryPage.style.display = 'flex';
      summaryPage.innerHTML = `
        <button id="back-button" class="btn">← Back to Files</button>
        <div class="summary-left">
          ${generateDetailedSummaryHTML(data.evaluation)}
          <div class="summary-controls">
            <button id="download-word" class="btn">Download Review</button>
          </div>
        </div>
        <div class="summary-right">
          <div id="pdf-viewer-wrapper">
            <div id="pdf-viewer-container"></div>
          </div>
        </div>
      `;
      summaryPage.classList.add("fade-in");
      setTimeout(() => { summaryPage.classList.remove("fade-in"); }, 600);
      
      const pdfViewerContainer = document.getElementById('pdf-viewer-container');
      const pdfViewerWrapper = document.getElementById('pdf-viewer-wrapper');
      
      // Initial render of the PDF pages
      renderPDFPages(data.file, pdfViewerContainer, pdfScale);
      
      // Gesture-based zooming:
      let initialScale = pdfScale;
      pdfViewerWrapper.addEventListener('gesturestart', function(e) {
        e.preventDefault();
        initialScale = pdfScale;
      });
      pdfViewerWrapper.addEventListener('gesturechange', function(e) {
        e.preventDefault();
        pdfScale = initialScale * e.scale;
        renderPDFPages(data.file, pdfViewerContainer, pdfScale);
      });
      
      // Zoom via ctrl+wheel:
      pdfViewerWrapper.addEventListener('wheel', function(e) {
        if (e.ctrlKey) {
          e.preventDefault();
          pdfScale += (e.deltaY < 0 ? 0.1 : -0.1);
          pdfScale = Math.max(0.1, pdfScale);
          renderPDFPages(data.file, pdfViewerContainer, pdfScale);
        }
      });
      
      // Toggle behavior for subsections:
      document.querySelectorAll('.section').forEach(sectionElem => {
        const subsectionsDiv = sectionElem.querySelector('.subsections');
        if (subsectionsDiv) {
          const header = sectionElem.querySelector('h3, h2');
          header.style.cursor = "pointer";
          header.addEventListener('click', () => {
            if (subsectionsDiv.style.display === "none" || subsectionsDiv.style.display === "") {
              subsectionsDiv.style.display = "block";
              const toggleIcon = header.querySelector('.toggle-icon');
              if (toggleIcon) toggleIcon.textContent = "▼";
            } else {
              subsectionsDiv.style.display = "none";
              const toggleIcon = header.querySelector('.toggle-icon');
              if (toggleIcon) toggleIcon.textContent = "▶";
            }
          });
        }
      });
      
      setupDownloadButtons(data.evaluation);
      createChatbot();
      chatMemory = [];
    }
    
    function setupDownloadButtons(evaluation) {
      document.getElementById('download-word').onclick = () => { downloadFormattedSummary(evaluation, "word"); };
    }
    
    // Back button handler:
    document.addEventListener('click', function(e) {
      if(e.target && e.target.id === 'back-button'){
        summaryPage.classList.add("fade-out");
        setTimeout(() => {
          summaryPage.style.display = 'none';
          mainPage.style.display = 'block';
          document.querySelector("header").style.display = "flex";
          document.getElementById("info-button").style.display = "flex";
          const chatbotToggle = document.getElementById('chatbot-toggle');
          const chatbotContainer = document.getElementById('chatbot-container');
          if (chatbotToggle) chatbotToggle.style.display = 'none';
          if (chatbotContainer) chatbotContainer.classList.remove("visible");
          summaryPage.classList.remove("fade-out");
        }, 300);
      }
    });
    
    /********************************************************************
     * Chatbot Implementation with Memory and Document Context
     ********************************************************************/
    function createChatbot() {
      let chatbotToggle = document.getElementById('chatbot-toggle');
      let chatbotContainer = document.getElementById('chatbot-container');
      if (!chatbotToggle) {
        chatbotToggle = document.createElement('div');
        chatbotToggle.id = "chatbot-toggle";
        chatbotToggle.className = "chatbot-toggle";
        chatbotToggle.innerHTML = "💬";
        document.body.appendChild(chatbotToggle);
      }
      if (!chatbotContainer) {
        chatbotContainer = document.createElement('div');
        chatbotContainer.id = "chatbot-container";
        chatbotContainer.className = "chatbot-container";
        chatbotContainer.innerHTML = `
          <div id="chatbot-drag-handle" class="chatbot-drag-handle"></div>
          <div id="chatbot-header" class="chatbot-header">Document Chat</div>
          <div id="chatbot-messages" class="chatbot-messages"></div>
          <div class="chatbot-input-container">
            <input type="text" id="chatbot-input" placeholder="Type your message...">
            <button id="chatbot-send" class="btn">Send</button>
          </div>
        `;
        document.body.appendChild(chatbotContainer);
        makeChatbotResizable();
      }
      chatbotContainer.classList.remove("visible");
      chatbotToggle.style.display = "flex";
      
      if (!chatbotToggle.dataset.listenerAdded) {
        chatbotToggle.addEventListener('click', () => {
          if (chatbotContainer.classList.contains("visible")) { chatbotContainer.classList.remove("visible"); }
          else { chatbotContainer.classList.add("visible"); }
        });
        chatbotToggle.dataset.listenerAdded = "true";
      }
      
      const sendButton = document.getElementById('chatbot-send');
      const inputField = document.getElementById('chatbot-input');
      if (!sendButton.dataset.listenerAdded) {
        sendButton.addEventListener('click', sendChatMessage);
        sendButton.dataset.listenerAdded = "true";
      }
      if (!inputField.dataset.listenerAdded) {
        inputField.addEventListener('keypress', function(e) {
          if (e.key === 'Enter') sendChatMessage();
        });
        inputField.dataset.listenerAdded = "true";
      }
    }
    
    function makeChatbotResizable() {
      const handle = document.getElementById('chatbot-drag-handle');
      const container = document.getElementById('chatbot-container');
      handle.addEventListener('mousedown', initDrag);
      function initDrag(e) {
        e.preventDefault();
        document.addEventListener('mousemove', doDrag);
        document.addEventListener('mouseup', stopDrag);
      }
      function doDrag(e) {
        const rect = container.getBoundingClientRect();
        const newWidth = rect.right - e.clientX;
        const newHeight = rect.bottom - e.clientY;
        if(newWidth > 200) { container.style.width = newWidth + 'px'; }
        if(newHeight > 150) { container.style.height = newHeight + 'px'; }
      }
      function stopDrag(e) {
        document.removeEventListener('mousemove', doDrag);
        document.removeEventListener('mouseup', stopDrag);
      }
    }
    
    function appendChatMessage(sender, text, extraClass="") {
      const messagesContainer = document.getElementById('chatbot-messages');
      const messageElem = document.createElement('div');
      messageElem.classList.add('chatbot-message', sender);
      if (extraClass) messageElem.classList.add(extraClass);
      messageElem.textContent = text;
      messagesContainer.appendChild(messageElem);
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
      return messageElem;
    }
    
    function typeOutText(element, text, interval) {
      let index = 0;
      const timer = setInterval(() => {
        if (index < text.length) { element.textContent += text.charAt(index); index++; }
        else { clearInterval(timer); }
      }, interval);
    }
    
    async function sendChatMessage() {
      const inputElem = document.getElementById('chatbot-input');
      const message = inputElem.value.trim();
      if (!message) return;
      appendChatMessage("user", message);
      inputElem.value = "";
      
      chatMemory.push({ role: "user", content: message });
      if (chatMemory.length > 50) { chatMemory.shift(); }
      
      let contextText = currentDocumentOriginalText;
      
      const conversation = [
        { role: "system", content: "You are an AI assistant that only responds based on the following document (do not include any external information):\n" + contextText }
      ].concat(chatMemory);
      
      const totalTokenLimit = 200000;
      let conversationContent = conversation.map(msg => msg.content).join(" ");
      const conversationTokens = encode(conversationContent).length;
      const bufferTokens = 100;
      const computed = totalTokenLimit - conversationTokens - bufferTokens;
      const maxCompletionTokens = computed > 1000 ? Math.min(computed, 100000) : 1000;
      
      const typingElem = appendChatMessage("bot", "JurisCritique is thinking...", "typing");
      
      try {
        const response = await fetch("https://api.openai.com/v1/chat/completions", {
          method: "POST",
          headers: {
             "Content-Type": "application/json",
             "Authorization": `Bearer ${OPENAI_API_KEY}`
          },
          body: JSON.stringify({
            model: "o3-mini",
            messages: conversation,
            max_completion_tokens: maxCompletionTokens
          })
        });
        if (!response.ok) {
          typingElem.textContent = "Error: " + response.statusText;
          return;
        }
        const data = await response.json();
        const botReply = data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.content 
                         ? data.choices[0].message.content.trim() 
                         : "I don't have an answer.";
        typingElem.remove();
        const botMessageElem = appendChatMessage("bot", "", "");
        typeOutText(botMessageElem, botReply, 20);
        chatMemory.push({ role: "assistant", content: botReply });
        if (chatMemory.length > 50) { chatMemory.shift(); }
      } catch (err) {
        typingElem.textContent = "Error: " + err.message;
      }
    }
  </script>
</body>
</html>
